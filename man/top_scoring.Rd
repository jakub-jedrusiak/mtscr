% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/top_scoring.R
\name{top_scoring}
\alias{top_scoring}
\title{Simple top-scoring for creativity research}
\usage{
top_scoring(
  df,
  id_column,
  score_column,
  item_column = NULL,
  top = 1,
  by_item = FALSE,
  append = FALSE,
  aggregate_function = mean
)
}
\arguments{
\item{df}{Data frame in long format.}

\item{id_column}{Name of the column containing participant's unique id.}

\item{score_column}{Name of the column containing idea-level scores.}

\item{item_column}{Name of the column containing separate trials for the task (e.g., AUT items).
Optional. Supplying this argument changes the way the scores are calculated. See Deatils.}

\item{top}{A number or an integer vector specifying on how many best ideas
the final score should be based.}

\item{by_item}{Boolean specifying whether the return value should aggregate scores
from different items.}

\item{append}{Boolean specifying whether the return value should be a new data frame with
person-level scores (\code{FALSE}, default) or the original data frame with scores appended as
new columns (\code{TRUE}).}

\item{aggregate_function}{The function that should be used to aggregate idea-level scores
into person-level scores. Should be a function, not a call
(e.g., \code{aggregate_function = mean} and not \code{aggregate_function = mean()})}
}
\value{
The return value is a dataframe. By default, it contains an id column and a series
of score columns named \code{top1}, \code{top2} etc. for each element of the vector given in the \code{top}
argument. If \code{by_item = TRUE}, the return value also contains an item column with item indices.
A separate score for each item is calculated. If \code{append = TRUE}, the return value is the
original dataframe with the score columns appended.
}
\description{
Get creativity measures using simple top-scoring, i.e., calculate
a single index based only on top-X best scores.
}
\details{
The way the top-X scores are calculated is based mainly on the \code{aggregate_function} and
on whether the \code{item_column} was supplied. If the \code{item_column} wasn't supplied, the
top-X scores are the participants' best ideas across all trials. For example, if \code{top = 2},
then the score is based on the person's 2 best ideas, even if there were 3 different items
and both best ideas were uses for a brick.

Now if the \code{item_column} was supplied and \code{by_item = FALSE} (default), the score will be
based on X best ideas per item. For example, if \code{top = 2} and there were 3 different items,
the final score will be the mean of 6 best scores â€“ 2 per item. Set \code{by_item = TRUE} to
get separate scores for each item.
}
\examples{
data("mtscr_creativity", package = "mtscr")
mtscr_creativity <- mtscr_creativity |>
  dplyr::slice_sample(n = 500) # for performance, ignore

# Get top1, top2, and top3 scores for each participant
top_scoring(mtscr_creativity, id, SemDis_MEAN, item, top = 1:3)

# Get top2 scores ignoring items
top_scoring(mtscr_creativity, id, SemDis_MEAN, top = 2)

# Get top2-top4 scores for each item separately
top_scoring(mtscr_creativity, id, SemDis_MEAN, item, top = 2:4, by_item = TRUE)

# Add the scores to the original data frame
top_scoring(mtscr_creativity, id, SemDis_MEAN, item, top = 2:4, append = TRUE)

# Get scores by the sum of 3 top scores (note no parentheses after the function)
top_scoring(
  mtscr_creativity,
  id,
  SemDis_MEAN,
  item,
  top = 3,
  aggregate_function = sum
)

# Create a custom aggregate function (here: scale by 100, get the mean, and round)
top_scoring(
  mtscr_creativity,
  id,
  SemDis_MEAN,
  item,
  top = 1:3,
  aggregate_function = \(x) round(mean(x) * 100)
)

}
